import time
import bluetooth
import requests
from influxdb import InfluxDBClient

# ------------------------- CONFIGURATIONS -------------------------

INFLUX_HOST = "localhost"
INFLUX_PORT = 8086
INFLUX_DB = "AirQualityMonitoring"
MEASUREMENT = "Sensor-Data"

# THINGSPEAK_API_KEY = "F0SITC92UK0WBJ6D"
# THINGSPEAK_URL = "https://api.thingspeak.com/update"

# Initialize InfluxDB Client
client = InfluxDBClient(host=INFLUX_HOST, port=INFLUX_PORT, database=INFLUX_DB)

# ------------------------- FUNCTIONS -------------------------

def find_esp32_address(target_name="ESP32-BT-Server"):
    devices = bluetooth.discover_devices(duration=8, lookup_names=True)
    for addr, name in devices:
        if name == target_name:
            return addr
    return None

def store_data_in_influxdb(mq5_value, mq135_value):
    timestamp = int(time.time() * 1e9)  # nanoseconds
    data = [
        {
            "measurement": MEASUREMENT,
            "time": timestamp,
            "fields": {
                "MQ5": mq5_value,
                "MQ135": mq135_value
            }
        }
    ]
    client.write_points(data)
    print(f"Stored in InfluxDB: MQ5={mq5_value}, MQ135={mq135_value}")

/*
def send_to_thingspeak(mq5_value, mq135_value):
    payload = {
        "api_key": THINGSPEAK_API_KEY,
        "field1": mq5_value,
        "field2": mq135_value
    }
    requests.post(THINGSPEAK_URL, data=payload)

*/

# ------------------------- MAIN LOGIC -------------------------

def main():
    address = find_esp32_address()
    if address is None:
        print("ESP32 not found.")
        return

    print(f"Found ESP32: {address}")

    try:
        sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
        sock.connect((address, 1))
        print("Connected to ESP32")

        while True:
            sock.send("read\n")  # Request sensor data
            data = sock.recv(1024).decode('utf-8').strip()
            print(f"Received: {data}")

            try:
                # Expected format: "MQ5:123,MQ135:456"
                parts = data.split(',')
                mq5 = int(parts[0].split(':')[1])
                mq135 = int(parts[1].split(':')[1])

                store_data_in_influxdb(mq5, mq135)
                #send_to_thingspeak(mq5, mq135)

            except Exception as e:
                print(f"Error parsing data: {e}")

            time.sleep(15)

    except bluetooth.btcommon.BluetoothError as e:
        print(f"Bluetooth error: {e}")
    finally:
        sock.close()

if __name__ == "__main__":
    main()



esp code:

#include "BluetoothSerial.h"
#include <Wire.h>

BluetoothSerial SerialBT;

// Define sensor pins (analog)
const int MQ5_PIN = 34;    // GPIO34 for MQ5 (Analog)
const int MQ135_PIN = 35;   // GPIO35 for MQ135 (Analog)

void setup() {
  Serial.begin(115200);
  SerialBT.begin("ESP32-BT-Server"); // Bluetooth device name
  Serial.println("Bluetooth started. Waiting for connections...");

  // Initialize analog pins
  pinMode(MQ5_PIN, INPUT);
  pinMode(MQ135_PIN, INPUT);
}

void loop() {
  // Check for incoming Bluetooth commands
  if (SerialBT.available()) {
    String command = SerialBT.readStringUntil('\n');
    command.trim();

    if (command == "read") {
      // Read sensor values
      int mq5Value = analogRead(MQ5_PIN);
      int mq135Value = analogRead(MQ135_PIN);

      // Send data in format: "MQ5:123,MQ135:456"
      String data = "MQ5:" + String(mq5Value) + ",MQ135:" + String(mq135Value);
      SerialBT.println(data);
      Serial.println("Sent: " + data);  // Debug print
    }
  }

  delay(100); // Small delay to reduce CPU usage
}
------------
import time
import paho.mqtt.client as mqtt

# ThingSpeak MQTT settings
MQTT_BROKER = "mqtt.thingspeak.com"
MQTT_PORT = 1883
MQTT_CLIENT_ID = "uniqueClientID"  # Can be any unique string

THINGSPEAK_CHANNEL_ID = "YOUR_CHANNEL_ID"
THINGSPEAK_WRITE_API_KEY = "YOUR_WRITE_API_KEY"

def send_to_thingspeak_mqtt():

    """Sends latest MQ-5 and MQ-135 sensor data from InfluxDB to ThingSpeak via MQTT."""

    query = f'SELECT "MQ5", "MQ135" FROM "{MEASUREMENT}" ORDER BY time DESC LIMIT 1'
    result = client.query(query)
    points = list(result.get_points())

    if points:
        for point in points:
            mq5_value = point['MQ5']
            mq135_value = point['MQ135']
            payload = f"field1={mq5_value}&field2={mq135_value}"
            print(f"Publishing to ThingSpeak MQTT: {payload}")

            topic = f"channels/{THINGSPEAK_CHANNEL_ID}/publish/{THINGSPEAK_WRITE_API_KEY}"

            mqtt_client = mqtt.Client(MQTT_CLIENT_ID)
            mqtt_client.connect(MQTT_BROKER, MQTT_PORT, 60)
            mqtt_client.publish(topic, payload)
            mqtt_client.disconnect()

            print("Data sent via MQTT to ThingSpeak!")

            time.sleep(16)  # Wait more than 15 seconds to respect ThingSpeak limits
    else:
        print("No data found in InfluxDB!")

--------

#include "BluetoothSerial.h"

BluetoothSerial SerialBT;

const int led1Pin = 5;    // GPIO5 for LED 1
const int led2Pin = 18;   // GPIO18 for LED 2

void setup() {
  Serial.begin(115200);
  SerialBT.begin("ESP32-BT-Server"); // Bluetooth device name
  Serial.println("Bluetooth Started. Waiting for messages...");

  pinMode(led1Pin, OUTPUT);
  pinMode(led2Pin, OUTPUT);

  digitalWrite(led1Pin, LOW);  // Initialize LEDs OFF
  digitalWrite(led2Pin, LOW);
}

void loop() {
  if (SerialBT.available()) {
    String message = SerialBT.readStringUntil('\n');
    message.trim();

    Serial.println("Received: " + message);

    if (message == "High") {
      digitalWrite(led1Pin, HIGH);  // Turn LEDs ON
      digitalWrite(led2Pin, HIGH);
      SerialBT.println("LEDs: ON");
    } else if (message == "Low") {
      digitalWrite(led1Pin, LOW);  // Turn LEDs OFF
      digitalWrite(led2Pin, LOW);
      SerialBT.println("LEDs: OFF");
    } else {
      SerialBT.println("Invalid command. Use High or Low.");
    }
  }
}


---------------------------------------------------------------------------------

import bluetooth
import random
import time

# Search for your ESP32 device name
esp_name = "ESP32-BT-Server"

print("Searching for ESP32 Bluetooth device...")
devices = bluetooth.discover_devices(duration=8, lookup_names=True)

esp_address = None
for addr, name in devices:
    if name == esp_name:
        esp_address = addr
        break

if not esp_address:
    print("ESP32 not found!")
    exit()

# Connect to ESP32 on RFCOMM channel 1
sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
sock.connect((esp_address, 1))
print("Connected to ESP32")

try:
    while True:
        value = random.randint(0, 1)
        message = "High" if value == 1 else "Low"
        print(f"Sending: {message}")
        sock.send(message + "\n")  # Send with newline
        time.sleep(5)  # Send every 5 seconds

except KeyboardInterrupt:
    print("Stopping...")
    sock.close()

















#include <WiFi.h>
#include <WebServer.h>
#include <ArduinoJson.h>

// WiFi credentials
const char* ssid = "Your_SSID";
const char* password = "Your_PASSWORD";

WebServer server(80);

// Define LED pins
const int redLEDPin = 5;   // GPIO5 for red LED
const int blueLEDPin = 18; // GPIO18 for blue LED

void handleData() {
  if (server.hasArg("plain")) {
    String body = server.arg("plain");
    StaticJsonDocument<200> doc;
    DeserializationError error = deserializeJson(doc, body);

    if (!error) {
      int field3 = doc["field3"]; // Read as int
      int field4 = doc["field4"];

      Serial.println("Received from Raspberry Pi:");
      Serial.println("Field 3: " + String(field3));
      Serial.println("Field 4: " + String(field4));

      // Control LEDs
      digitalWrite(redLEDPin, field3 == 1 ? HIGH : LOW);
      digitalWrite(blueLEDPin, field4 == 1 ? HIGH : LOW);

      server.send(200, "text/plain", "LEDs updated");
    } else {
      server.send(400, "text/plain", "Invalid JSON");
    }
  } else {
    server.send(400, "text/plain", "No data received");
  }
}

void setup() {
  Serial.begin(115200);

  // Setup LED pins
  pinMode(redLEDPin, OUTPUT);
  pinMode(blueLEDPin, OUTPUT);
  digitalWrite(redLEDPin, LOW);
  digitalWrite(blueLEDPin, LOW);

  // Connect to Wi-Fi
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConnected. IP: " + WiFi.localIP().toString());

  // Set server route
  server.on("/data", HTTP_POST, handleData);
  server.begin();
}

void loop() {
  server.handleClient();
}

-------------------

Beacon 


#include <BLEDevice.h>               // Include BLE library for ESP32
#include <BLEUtils.h>
#include <BLEScan.h>
#include <math.h>                    // Include math library for distance calculation

BLEScan* pBLEScan;                  // Pointer to the BLE scanner object
BLEAddress beaconAddress("60:77:71:8e:74:1B"); // Target beacon's MAC address

// Function to estimate distance from RSSI using the path loss formula
float calculateDistance(int rssi) {
  int txPower = -64;               // signal strength at 1 meter for the used beacon
  float n = 2.0;                   // Environmental constant (2 for open space)
  return pow(10.0, ((txPower - rssi) / (10 * n))); // Distance in meters
}

// Custom callback class to handle advertised BLE devices 
class MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {
  void onResult(BLEAdvertisedDevice advertisedDevice) {
    if (advertisedDevice.getAddress().equals(beaconAddress)) { // If this is the beacon we care about
      int rssi = advertisedDevice.getRSSI();                   // Read signal strength
      float distance = calculateDistance(rssi);                // Estimate distance
      Serial.print("Found Beacon with RSSI: ");
      Serial.print(rssi);
      Serial.print(" | Estimated Distance: ");
      Serial.print(distance, 2);                               // Print with 2 decimal places
      Serial.println(" meters");
    }
  }
};

// Setup function runs once
void setup() {
  Serial.begin(115200);            // Start serial monitor
  BLEDevice::init("");             // Initialize BLE device
  pBLEScan = BLEDevice::getScan(); // Get BLE scanner instance
  pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks()); // Set our callback
  pBLEScan->setActiveScan(true);  // Enable active scanning (gets more data)
  pBLEScan->setInterval(50);      // Set scan interval
  pBLEScan->setWindow(49);        // Set scan window (almost equal to interval)
}

// Loop function runs continuously
void loop() {
  pBLEScan->start(4, false);       // Start scanning for 4 seconds
}

-------

#include <SPI.h>
#include <MFRC522.h>

#define RST_PIN 22  // Reset pin for MFRC522
#define SS_PIN 5    // Slave Select pin for MFRC522

MFRC522 mfrc522(SS_PIN, RST_PIN);  // Create MFRC522 instance

void setup() {
  Serial.begin(115200);  // Start serial communication
  SPI.begin();           // Init SPI bus
  mfrc522.PCD_Init();    // Init MFRC522 module
  Serial.println("Scan an RFID tag to see its UID...");
}

void loop() {
  // Look for a new card
  if (mfrc522.PICC_IsNewCardPresent()) {
    if (mfrc522.PICC_ReadCardSerial()) {
      char tagID[16];
      for (byte i = 0; i < mfrc522.uid.size; i++) {
        snprintf(tagID + (i * 2), 3, "%02X", mfrc522.uid.uidByte[i]);
      }

      // Print UID
      Serial.print("RFID Tag UID: ");
      Serial.println(tagID);
    }
  }
}

